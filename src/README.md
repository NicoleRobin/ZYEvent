# zyevent 开发进度

## 计划
> 从最简单的使用opoll的一个类似echo的网络服务器开始，逐步扩展，形成一个完整的类似于libevent的网络库，把每个阶段的开发进度记录在这里。

## 版本
V_0.1
> 利用epoll实现一个简单的网络服务器，服务器的功能是：接收连接，接收消息，对一个每一个收到的消息，回复一个"Recv data!"的消息。  
> 下一个版本计划通过添加一个map来保存客户端发送过来的消息，在套接字可写时，把消息发送出去，实现一个真正的echo服务器。

V_0.2
> 通过一个map来保存客户端发送过来的消息，实现了一个真正的echo服务器。  

V_0.3
> 该版本实现了回调，与上一个版本中使用epoll_event.data.fd保存套接字描述符不同，这次利用epoll_event.data.ptr来保存一个定义的结构体struct event，该结构中包含套接字描述符，关心的事件，缓冲区，缓冲区中数据长度，已发送的偏移量，回调函数。  
> 添加了设置套接字为非阻塞的函数setnonblock。  
> 下个版本需要解决的问题：1.客户端关闭时，服务器无法知道，所以需要有一个机制来判断现在客户端是不是已经关闭了。  

v_0.4
> 对于上一个版本说到问题，我首先想到的办法就是在结构体中定义个变量来保存上次收到消息的时间戳，然后在每次处理完事件后，判断是否有超时的套接字，将其从epfd中删除并关闭即可。  
> 这里是我想错了，如果客户端正常关闭的话，服务器是可以感知到的，需要用超时来处理的是那些客户端直接崩溃导致没有给服务器发送关闭请求的情况。  
> 我做了个小实验，使用kill -9把已连接的客户端杀死，服务器还是可以立即感知到，不知道是什么原因造成，这里超时处理先不考虑，等搞明白这个问题再说。  

### 问题
1. 按照目前的设计，可以看到在read_cb中读完数据需要修改注册的事件为EPOLLOUT，在write_cb中写完数据后需要修改注册的事件为EPOLLIN，这是因为正常情况下，epollout事件总是激活的（LT模式下），所以当数据写完之后需要修改注册事件为epollin，等待数据到来，但是socket是全双工的端口，按现在的设计读写不能同时进行，那不是浪费了么？不知道libevent这块是怎么设计的。
2. 上面说的超时检测，我认为应该是客户端出现无法发送关闭连接的情况下，服务器如何删除这些已经‘死’的连接，上面的办法是在epoll_wait返回并处理完事件之后，这种办法是不行的，它有一个默认的前提，就是仍然还有客户端存活，现在假如出现这种情况：所有的client同时崩溃，那么服务器就会一直卡在epoll_wait，永远无法做出处理。所以这里需要一个定时事件，既保证了即使所有的client崩溃也能不会一直阻塞在epoll_wait上，同时也达到一个定时处理的目的。

V_0.5
> 把操作事件的代码提取出来几个函数放在单独的文件中。   

### 问题
1. libevent中的event对应一个事件而不是一个套接字，所以如果要完成一个套接字的读写操作，要么需要两个event对象（就像bufferevent结构一样，包含evread、evwrite两个事件），要么就需要在把要发送的数据放到发送缓冲区之后，调用event_add，在发送数据发送完毕之后调用event_del。
2. libevent中的event结构本身没有提供缓冲区，所以如果仅仅使用event结构（不使用bufferevent）是没办法实现一个完成的服务器的，需要额外的空间保存buffer。
3. 已经搞明白了libevent是怎么设计的，如果按照它的设计来的话就没有什么创意了，但是又没有想出更好的方案，所以暂时搁置对zyevent的开发，准备了解一下muduo，看一下它的设计是不是有更好的地方，然后综合两者的设计，再继续zyevent的开发。  
